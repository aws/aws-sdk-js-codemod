import { readFile, writeFile } from "fs/promises";
import { join } from "path";
import jscodeshift, { Identifier, TSQualifiedName, TSTypeReference } from "jscodeshift";
import { format } from "prettier";

import { CLIENT_NAMES } from "../../src/transforms/v2-to-v3/config";

const codegenComment = `// This file is generated by scripts/generateReqResTypesMap/index.ts
// Do not edit this file directly. Instead, edit the script and run it to regenerate this file.`;

const filePath = join("src", "transforms", "v2-to-v3", "config", "CLIENT_REQ_RES_TYPES_MAP.ts");
const relativeFilePath = join(__dirname, "..", "..", filePath);

(async () => {
  let fileContent = codegenComment;

  fileContent += `\n\n/* eslint-disable @typescript-eslint/naming-convention */`;
  fileContent += `\nexport const CLIENT_REQ_RES_TYPES_MAP: Record<string, Record<string, string>> = `;

  const reqResTypesMap = {};
  const clientsDir = join("node_modules", "aws-sdk", "clients");

  for (const clientName of CLIENT_NAMES) {
    const typesPath = join(clientsDir, `${clientName.toLowerCase()}.d.ts`);
    const relativeTypesPath = join(__dirname, "..", "..", typesPath);

    const typesCode = await readFile(relativeTypesPath, "utf8");

    const j = jscodeshift.withParser("ts");
    const source = j(typesCode);

    source.find(j.ClassDeclaration, { id: { name: clientName } }).forEach((classDeclaration) => {
      const classMethods = j(classDeclaration).find(j.TSDeclareMethod).nodes();

      classMethods.forEach((classMethod) => {
        if (classMethod.key.type !== "Identifier") return;
        if (classMethod.key.name === "constructor") return;
        if (classMethod.key.name.startsWith("waitFor")) return;

        const classMethodKeyName = (classMethod.key as Identifier).name;
        const commandName =
          classMethodKeyName.charAt(0).toUpperCase() + classMethodKeyName.slice(1);

        if (classMethod.params.length !== 2) return;
        if (classMethod.params[0].type !== "Identifier") return;
        if (classMethod.params[0].name !== "params") return;

        const params = classMethod.params[0] as Identifier;

        if (!params.typeAnnotation) return;
        if (!params.typeAnnotation.typeAnnotation) return;
        if (params.typeAnnotation.typeAnnotation.type !== "TSTypeReference") return;
        const paramsTypeRef = params.typeAnnotation!.typeAnnotation! as TSTypeReference;

        if (!paramsTypeRef.typeName) return;
        if (paramsTypeRef.typeName.type !== "TSQualifiedName") return;
        const paramsTypeRefName = paramsTypeRef.typeName as TSQualifiedName;

        if (!paramsTypeRefName.right) return;
        if (paramsTypeRefName.right.type !== "Identifier") return;
        const paramsTypeName = (paramsTypeRef.typeName as TSQualifiedName).right as Identifier;
        const requestTypeName = paramsTypeName.name;

        if (!requestTypeName.startsWith(commandName)) {
          if (reqResTypesMap[requestTypeName] === undefined) reqResTypesMap[requestTypeName] = {};
          reqResTypesMap[requestTypeName][clientName] = commandName;

          const responseTypeName = requestTypeName.replace("Request", "Response");
          if (reqResTypesMap[responseTypeName] === undefined) reqResTypesMap[responseTypeName] = {};
          reqResTypesMap[responseTypeName][clientName] = commandName;
        }
      });
    });
  }

  fileContent += JSON.stringify(reqResTypesMap);
  fileContent += `;\n`;

  await writeFile(
    relativeFilePath,
    await format(fileContent, { parser: "typescript", printWidth: 100 })
  );
})();
